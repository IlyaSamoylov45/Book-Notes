Chapter 3. Processes 101
  - Erlang VM supports 134 million processes!
  - The processes created by Erlang VM are independent of the OS; they're lighter weight and take microseconds to create.

3.1. Actor concurrency model
  - Erlang (and Elixir) uses the Actor concurrency model. Meaning:
    1. Each actor is a process.
    2. Each process performs a specific task.
    3. To tell a process to do something, you need to send it a message. The process can reply by sending back another message.
    4. The kinds of messages the process can act on are specific to the process itself. In other words, messages are pattern-matched.
    5. Other than that, processes don’t share any information with other processes.
  - The actor concurrency model like people, responds only to certain kinds of messages.

3.2 Building a weather application
  - One of the properties of concurrency is that you never know the order of the responses.

3.2.1. The naïve version
  - Every project generated by mix contains mix.exs file.
  - mix.exs consists of two public functions: project and application.
  - The project function sets up project. More importantly, it sets up the project’s dependencies by invoking the deps private function.
  - The application function is used to generate an application resource file.

3.3. The worker

3.3.1. Taking the worker for a spin

3.4. Creating processes for concurrency
  - The built-in spawn function creates a process.
  - pid = spawn(Metex.Worker, :loop, [])

3.4.1. Receiving messages
  - With the pid, you can send the process messages. The kinds of messages the process can receive are defined in the receive block

3.4.2. Sending messages
  - Messages are sent using the built-in send/2 function. The first argument is the pid of the process you want to send the message to. The second argument is the actual message
  - To get back responses from the shell session, you can use the built-in flush/0 function
  - flush/0 clears out all the messages that were sent to the shell and prints them out.
  - You need a recursive call to the message-handling logic.

3.5. Collecting and manipulating results with another actor

3.5.1. {:ok, result}—the happy path message

3.5.2. :exit—the poison-pill message

3.5.4. The bigger picture
  - It’s important to remember that there’s no shared memory. The only way a change of state can occur within a process is when a message is sent to it.
